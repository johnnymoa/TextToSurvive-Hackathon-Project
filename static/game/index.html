<!DOCTYPE html>
<html>
<head>
    <title>Get Me Out! - Apartment Escape Game with Chat</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="/static/game/gameState.js"></script>
    <script src="/static/game/mistral.js"></script>
    <script src="/static/game/girlfriend.js"></script>
    <style>
        /* Layout */
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            display: flex;
            background-color: #220a0a;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }
        #gameContainer {
            display: flex;
            width: 100%;
            height: 100%;
            max-height: 100vh;
            position: relative;
            z-index: 2;
        }
        #mapSection {
            flex: 1;
            min-width: 0;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* We'll place the P5 canvas in here */
        .map-wrapper {
            margin: 20px;
            transform-origin: top left;
        }

        #chatSection {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: #000000;
            border-radius: 38px;
            overflow: hidden;
        }
        #chatHistory {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            background: #f8f8fa;
        }
        /* Style moderne pour la barre de scroll */
        #chatHistory::-webkit-scrollbar {
            width: 6px;
        }
        #chatHistory::-webkit-scrollbar-track {
            background: transparent;
        }
        #chatHistory::-webkit-scrollbar-thumb {
            background: #d1d1d6;
            border-radius: 3px;
        }
        #chatControls {
            padding: 16px;
            background: #ffffff;
            display: flex;
            gap: 12px;
            border-top: 1px solid #f1f1f5;
        }
        .chat-message {
            padding: 12px 16px;
            margin: 6px 0;
            border-radius: 20px;
            max-width: 75%;
            font-size: 0.95em;
            line-height: 1.4;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        .user-message {
            background: #007aff;
            color: white;
            margin-left: auto;
            border-radius: 20px 20px 4px 20px;
        }
        .assistant-message {
            background: #f1f1f5;
            color: #000000;
            margin-right: auto;
            border-radius: 20px 20px 20px 4px;
        }
        input {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 20px;
            font-family: inherit;
            font-size: 0.95em;
            background: #f1f1f5;
            transition: background 0.2s;
        }
        input:focus {
            outline: none;
            background: #e5e5ea;
        }
        input::placeholder {
            color: #8e8e93;
        }
        button {
            padding: 8px;
            width: 40px;
            height: 40px;
            background: #007aff;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, background 0.2s;
        }
        button:hover {
            background: #0056b3;
            transform: scale(1.05);
        }
        /* Style moderne pour l'indicateur de chargement */
        .loading-dots {
            display: inline-flex;
            gap: 4px;
            padding: 8px 12px;
            background: #f1f1f5;
            border-radius: 16px;
        }
        .dot {
            width: 6px;
            height: 6px;
            background: #8e8e93;
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out;
        }
        .dot:nth-child(1) {
            animation-delay: -0.32s;
        }
        .dot:nth-child(2) {
            animation-delay: -0.16s;
        }
        @keyframes bounce {
            0%,
            80%,
            100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1);
            }
        }

        /* Modal for API key (if needed) */
        #apiKeyModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
        }
        #apiKey {
            width: 100%;
            margin: 10px 0;
            padding: 8px;
        }

        /* Modifier les styles du chat et du mockup */
        .phone-mockup {
            position: relative;
            width: 400px;
            height: 100%;
            max-height: 800px;
            min-height: 600px;
            background: url("/static/assets/img/phone.png") no-repeat center;
            background-size: contain;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: auto;
            padding: 35px 0;
        }

        .phone-screen {
            width: 90%;
            height: 96.5%;
            position: relative;
            overflow: hidden;
            margin: 0;
            border-radius: 50px;
            display: flex;
            flex-direction: column;
        }

        /* Media queries pour s'adapter aux différentes tailles d'écran */
        @media (max-height: 700px) {
            .phone-mockup {
                min-height: 500px;
                padding: 10px 0;
            }

            .phone-screen {
                width: 90%;
                height: 96.5%;
            }

            #chatHistory {
                padding: 8px;
            }

            #chatControls {
                padding: 8px;
            }
        }

        @media (max-width: 1200px) {
            #mapSection {
                flex: 0.6;
            }
        }

        /* Ajouter les nouveaux styles pour l'en-tête du chat */
        #chatHeader {
            padding: 16px;
            justify-content: center;
            background: #ffffff;
            border-bottom: 1px solid #f1f1f5;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .profile-picture {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #f1f1f5;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-name {
            font-size: 1.1em;
            font-weight: 600;
            color: #000000;
        }

        /* LED Bar */
        .led-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 0, 0, 0.4) 20%,
                rgba(255, 0, 0, 0.8) 35%,
                rgba(255, 50, 50, 1) 50%,
                rgba(255, 0, 0, 0.8) 65%,
                rgba(255, 0, 0, 0.4) 80%,
                transparent 100%
            );
            z-index: 100;
            animation: ledFlicker 4s infinite, ledPulse 10s infinite;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.7),
                        0 0 35px rgba(255, 0, 0, 0.5),
                        0 0 50px rgba(255, 0, 0, 0.4),
                        0 0 70px rgba(155, 0, 0, 0.3);
            filter: blur(0.6px);
        }

        .light-beam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 250px;
            background: linear-gradient(
                180deg,
                rgba(255, 0, 0, 0.3) 0%,
                rgba(255, 0, 0, 0.2) 20%,
                rgba(255, 0, 0, 0.15) 30%,
                rgba(155, 0, 0, 0.08) 60%,
                transparent 100%
            );
            animation: beamFlicker 4s infinite;
            pointer-events: none;
            filter: blur(2px);
        }

        @keyframes ledFlicker {
            0% { opacity: 1; }
            95% { opacity: 1; }
            96% { opacity: 0.3; }
            97% { opacity: 1; }
            98% { opacity: 0.2; }
            99% { opacity: 0.9; }
            100% { opacity: 1; }
        }

        @keyframes ledPulse {
            0% { filter: brightness(1) blur(0.6px); }
            50% { filter: brightness(1.3) blur(0.4px); }
            100% { filter: brightness(1) blur(0.6px); }
        }

        @keyframes beamFlicker {
            0% { opacity: 0.7; }
            95% { opacity: 0.7; }
            96% { opacity: 0.2; }
            97% { opacity: 0.7; }
            98% { opacity: 0.1; }
            99% { opacity: 0.6; }
            100% { opacity: 0.7; }
        }

        /* Background Elements */
        .background-elements {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .blood {
            position: absolute;
            top: 94%;
            opacity: 0.6;
            transform: rotate(20deg);
            right: 10%;
        }

        .blood-top-left {
            top: 0;
            left: 0;
            width: 300px;
        }

        .blood-top-right {
            top: 0;
            right: 0;
            width: 200px;
            transform: rotate(20deg);
        }

        .splatter {
            bottom: 20%;
            left: 10%;
            width: 200px;
        }

        .blood-bottom-right {
            bottom: 0;
            right: 0;
            position: absolute;
            top: 90%;
            left: 90%;
            width: 200px;
        }
    </style>
</head>
<body>
    <div class="led-bar">
        <div class="light-beam"></div>
    </div>
    <div class="background-elements">
        <img src="/static/assets/img/blood-2.png" alt="" class="blood blood-top-left" />
        <img src="/static/assets/img/help.png" alt="" class="blood blood-top-right" />
        <img src="/static/assets/img/splatter.png" alt="" class="blood splatter" />
        <img src="/static/assets/img/hand.png" alt="" class="blood blood-bottom-right" />
    </div>
    <div id="gameContainer">
        <div id="mapSection">
            <div id="mapWrapper" class="map-wrapper">
                <!-- P5.js canvas goes here -->
            </div>
        </div>
        <div class="phone-mockup">
            <div class="phone-screen">
                <div id="chatSection">
                    <div id="chatHeader">
                        <div class="profile-picture">
                            <!-- L'image sera ajoutée ici plus tard -->
                        </div>
                        <div class="chat-name">Bae 💖😘</div>
                    </div>
                    <div id="chatHistory"></div>
                    <div id="chatControls">
                        <input type="text" id="prompt" placeholder="Type your message...">
                        <button onclick="Message()">▶</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* 
         * This script loads ./apt.json to set up the map,
         * draws it in p5.js, and provides a chat interface on the right.
         */

        // Constants and variables for the map
        const CELL_SIZE = 30;
        let GRID_COLS = 0;
        let GRID_ROWS = 0;
        let grid = [];
        let rooms = new Map();
        let hidingPlaces = new Map(); // Add hiding places map
        let girlfriend;
        let baseMap; // Add baseMap variable
        let gfImage;

        // Initialize game state
        const gameState = new GameState();

        // Chat variables
        let chatMessages = []; // Array to store chat history

        // Load apt.json upon page start
        async function loadAptJson() {
            try {
                const response = await fetch('/static/game/apt.json');
                if (!response.ok) {
                    alert("Failed to load apt.json!");
                    return;
                }
                const data = await response.json();
                // Update local variables from apt.json
                GRID_COLS = data.gridCols || 40;
                GRID_ROWS = data.gridRows || 20;
                grid = data.grid || [];
                
                // Ensure each cell has the color property if it exists in the data
                for (let y = 0; y < GRID_ROWS; y++) {
                    for (let x = 0; x < GRID_COLS; x++) {
                        if (!grid[y]) grid[y] = [];
                        if (!grid[y][x]) {
                            grid[y][x] = { type: 'empty', color: null };
                        } else if (typeof grid[y][x] === 'string') {
                            // Handle old format where grid cells were just strings
                            grid[y][x] = { type: grid[y][x], color: null };
                        }
                    }
                }
                
                rooms = new Map(data.rooms);
                hidingPlaces = new Map(data.hidingPlaces || []);
                
                // Initialize girlfriend with starting position
                gfImage = loadImage('assets/img/gf.png');
                girlfriend = new Girlfriend(gameState, gfImage);
                girlfriend.setCharacterPosition(data.characterPos || { x: 0, y: 0 });

                // Once loaded, initialize the P5 canvas with correct dims
                let canvas = createCanvas(GRID_COLS * CELL_SIZE, GRID_ROWS * CELL_SIZE);
                canvas.parent('mapWrapper');
                adjustScale();

            } catch (e) {
                console.error("Error loading apt.json:", e);
            }
        }

        function adjustScale() {
            const availableWidth = window.innerWidth - 400 - 40; // space for chat + margins
            const actualCanvasWidth = GRID_COLS * CELL_SIZE;
            const scale = availableWidth / actualCanvasWidth;
            const mapWrapper = document.querySelector('#mapSection .map-wrapper');
            if (mapWrapper) {
                // use CSS zoom or transform
                mapWrapper.style.zoom = scale;
            }
        }

        window.addEventListener('resize', adjustScale);

        // p5.js setup
        function setup() {
            // We'll wait to createCanvas until apt.json is loaded
            window._p5 = window;
            baseMap = loadImage('/assets/img/appartment/BaseMap.PNG'); // Load the base map image
            loadAptJson();
        }

        // p5.js draw loop
        function draw() {
            if (!grid || grid.length === 0) {
                // No grid loaded yet or apt.json not ready
                return;
            }
            // background(255);
            // Draw the base map image
            if (baseMap) {
                image(baseMap, 0, 0, GRID_COLS * CELL_SIZE, GRID_ROWS * CELL_SIZE);
            }
            // drawGrid();
             drawRooms();
            // drawWallsAndDoors();
            if (girlfriend) {
                girlfriend.drawPath(window._p5, CELL_SIZE);
                girlfriend.drawCharacter(window._p5, CELL_SIZE);
            }
        }

        function drawGrid() {
            stroke(200);
            for (let x = 0; x <= GRID_COLS; x++) {
                line(x * CELL_SIZE, 0, x * CELL_SIZE, GRID_ROWS*CELL_SIZE);
            }
            for (let y = 0; y <= GRID_ROWS; y++) {
                line(0, y * CELL_SIZE, GRID_COLS*CELL_SIZE, y * CELL_SIZE);
            }
        }

        function drawRooms() {
            for (let [roomName, cells] of rooms) {
                const hue = stringToHue(roomName);
                fill(hue, 30, 95, 0.3);
                noStroke();
                for (let cell of cells) {
                    rect(cell.x * CELL_SIZE, cell.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
                if (cells.length > 0) {
                    fill(0);
                    textAlign(CENTER, CENTER);
                    textSize(10);
                    text(
                        roomName,
                        cells[0].x * CELL_SIZE + CELL_SIZE / 2,
                        cells[0].y * CELL_SIZE + CELL_SIZE / 2
                    );
                }
            }

            for (let [hidingName, hideCells] of hidingPlaces) {
                // Draw the hiding place cells
                fill(100, 30, 95, 0.3);
                noStroke();
                for (let cell of hideCells) {
                    rect(cell.x * CELL_SIZE, cell.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }

                if (hideCells.length > 0) {
                    const x = hideCells[0].x * CELL_SIZE + CELL_SIZE / 2;
                    const y = hideCells[0].y * CELL_SIZE + CELL_SIZE / 2;

                    push();
                    textAlign(CENTER, CENTER);
                    textSize(10);

                    // Measure exactly the text size (no extra padding)
                    const labelWidth = textWidth(hidingName);
                    const labelHeight = textAscent() + textDescent();

                    // Draw a centered background rectangle 
                    // that's just as wide/tall as the text
                    rectMode(CENTER);
                    fill('#f1c94f');
                    noStroke();
                    rect(x, y, labelWidth, labelHeight/2, 2);
                    pop();

                    // Draw the text on top
                    fill(0);
                    textAlign(CENTER, CENTER);
                    textSize(10);
                    text(hidingName, x, y);
                }
            }
        }

        function drawWallsAndDoors() {
            for (let y = 0; y < GRID_ROWS; y++) {
                for (let x = 0; x < GRID_COLS; x++) {
                    const cell = grid[y][x];
                    if (cell.type === 'wall') {
                        fill(0);
                        noStroke();
                        rect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    } else if (cell.type === 'door') {
                        fill(139, 69, 19); // Brown color for doors
                        noStroke();
                        rect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    } else if (cell.color) {
                        noStroke();
                        switch(cell.color) {
                            case 'yellow':
                                fill('#ffeb3b');
                                break;
                            case 'blue':
                                fill('#2196f3');
                                break;
                            case 'green':
                                fill('#4caf50');
                                break;
                            case 'red':
                                fill('#f44336');
                                break;
                        }
                        rect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
        }

        function stringToHue(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            return hash % 360;
        }

        // Simple BFS for pathfinding
        window.findPath = function(start, end) {
            const queue = [[start]];
            const visited = new Set();
            const key = pos => `${pos.x},${pos.y}`;
            visited.add(key(start));

            while (queue.length > 0) {
                const currentPath = queue.shift();
                const current = currentPath[currentPath.length - 1];

                if (current.x === end.x && current.y === end.y) {
                    return currentPath;
                }
                const neighbors = [
                    { x: current.x, y: current.y - 1 },
                    { x: current.x+1, y: current.y },
                    { x: current.x, y: current.y+1 },
                    { x: current.x-1, y: current.y }
                ];
                for (const next of neighbors) {
                    if (next.x < 0 || next.x >= GRID_COLS || next.y < 0 || next.y >= GRID_ROWS) continue;
                    if (visited.has(key(next))) continue;

                    const cell = grid[next.y][next.x];
                    if (cell.type === 'wall') continue;

                    visited.add(key(next));
                    queue.push([...currentPath, next]);
                }
            }
            return [];
        }

        function moveToRoom(roomName) {
            const targetRoom = Array.from(rooms.entries())
                .find(([name]) => name.toLowerCase() === roomName.toLowerCase());
            if (!targetRoom || !girlfriend) return false;

            const [_, cells] = targetRoom;
            if (cells.length === 0) return false;
            path = findPath(girlfriend.getCharacterPosition(), cells[0]);
            if (path.length > 0) {
                girlfriend.move(path);
                return true;
            }
            return false;
        }

        function moveToHidingSpot(hidingSpotName) {
            if (!girlfriend) return false;

            // Find the hiding place coordinates from apt.json data
            const hidingSpotData = Array.from(hidingPlaces.entries())
                .find(([name]) => name.toLowerCase() === hidingSpotName.toLowerCase());
            
            if (!hidingSpotData || !hidingSpotData[1] || hidingSpotData[1].length === 0) return false;

            // Use the first cell of the hiding place as the target
            const targetCell = hidingSpotData[1][0];
            path = findPath(girlfriend.getCharacterPosition(), targetCell);
            
            if (path.length > 0) {
                girlfriend.hide(path);
                return true;
            }
            return false;
        }

        /* Chat / Mistral-related code */
        function createLoadingIndicator() {
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'chat-message assistant-message';
            loadingDiv.innerHTML = `
                <div class="loading-dots">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                </div>
            `;
            return loadingDiv;
        }

        function addMessageToChat(role, content) {
            const chatHistory = document.getElementById('chatHistory');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}-message`;
            messageDiv.textContent = content;
            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;

            // Store message in chat history
            chatMessages.push({ role, content });
        }

        // Initialize Mistral API
        const mistralAPI = new MistralAPI();

        // Make rooms and hidingPlaces available globally
        window.rooms = rooms;
        window.hidingPlaces = hidingPlaces;

        // Update Message function to use girlfriend instance
        function Message() {
            if (girlfriend) {
                girlfriend.sendMessage();
            }
        }

        // Allow sending message with Enter
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('prompt').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    Message();
                }
            });
        });
    </script>
</body>
</html> 