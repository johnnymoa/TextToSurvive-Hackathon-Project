<!DOCTYPE html>
<html>

<head>
    <title>Get Me Out! - Apartment Escape Game with Chat</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="/static/game/gameState.js"></script>
    <script src="/static/game/mistral.js"></script>
    <script src="/static/game/girlfriend.js"></script>
    <script src="/static/game/clown.js"></script>
    <link rel="stylesheet" href="/static/assets/css/game-style.css" />
</head>

<body>
    <div class="led-bar">
        <div class="light-beam"></div>
    </div>
    <div class="background-elements">
        <img src="/static/assets/img/blood-2.png" alt="" class="blood blood-top-left" />
        <img src="/static/assets/img/help.png" alt="" class="blood blood-top-right" />
        <img src="/static/assets/img/splatter.png" alt="" class="blood splatter" />
        <img src="/static/assets/img/hand.png" alt="" class="blood blood-bottom-right" />
    </div>
    <div id="gameContainer">
        <div id="mapSection">
            <div id="mapWrapper" class="map-wrapper">
                <!-- P5.js canvas goes here -->
            </div>
        </div>
        <div class="phone-mockup">
            <div class="phone-screen">
                <div id="chatSection">
                    <div id="chatHeader">
                        <div class="profile-picture">
                            <!-- L'image sera ajoutÃ©e ici plus tard -->
                        </div>
                        <div class="chat-name">Bae ðŸ’–ðŸ˜˜</div>
                    </div>
                    <div id="chatHistory"></div>
                    <div id="chatControls">
                        <input type="text" id="prompt" placeholder="Type your message...">
                        <button onclick="Message()">
                            <svg width="683" height="683" viewBox="0 0 683 683" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <path
                                    d="M22.2666 1.86666C19.5999 2.93333 16.5333 4.39999 15.4666 5.19999C11.9999 8.13333 9.33325 15.7333 9.33325 22.5333C9.33325 28.1333 65.4666 283.333 66.9333 284.667C67.3333 285.067 339.333 332.267 372.4 337.733C381.733 339.333 389.333 340.933 389.333 341.333C389.333 341.733 381.733 343.333 372.4 344.933C339.2 350.4 67.3333 397.6 66.9333 398C65.4666 399.333 9.33325 654.533 9.33325 660.133C9.33325 675.867 21.0666 685.333 35.8666 681.333C42.6666 679.467 662.267 362 666.4 358.133C671.333 353.733 673.333 348.8 673.333 341.333C673.333 333.867 671.333 328.933 666.4 324.533C662.533 320.933 43.0666 3.19999 36.2666 1.33333C29.9999 -0.400007 28.5333 -0.266674 22.2666 1.86666Z"
                                    fill="white" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="sound-button" onclick="toggleSound()">
        <img src="/static/assets/img/sondon.png" alt="Sound control" id="soundIcon" />
    </div>

    <audio id="bgMusic" loop>
        <source src="/static/assets/sounds/music.mp3" type="audio/mp3" />
    </audio>

    <audio id="messageSound">
        <source src="/static/assets/sounds/message.wav" type="audio/wav" />
    </audio>

    <audio id="walkingSound" loop>
        <source src="/static/assets/sounds/walking.mp3" type="audio/mp3" />
    </audio>

    <script>
        /* 
         * This script loads ./apt.json to set up the map,
         * draws it in p5.js, and provides a chat interface on the right.
         */

        // Constants and variables for the map
        const CELL_SIZE = 30;
        let GRID_COLS = 0;
        let GRID_ROWS = 0;
        let grid = [];
        let rooms = new Map();
        let hidingPlaces = new Map(); // Add hiding places map
        let girlfriend;
        let clown;
        let baseMap; // Add baseMap variable
        let girlfriendImg;
        let clownImg;

        // Initialize game state
        const gameState = new GameState();

        // Chat variables
        let chatMessages = []; // Array to store chat history

        // Load apt.json upon page start
        async function loadAptJson() {
            try {
                const response = await fetch('/static/game/apt.json');
                if (!response.ok) {
                    alert("Failed to load apt.json!");
                    return;
                }
                const data = await response.json();
                // Update local variables from apt.json
                GRID_COLS = data.gridCols || 40;
                GRID_ROWS = data.gridRows || 20;
                grid = data.grid || [];

                // Ensure each cell has the color property if it exists in the data
                for (let y = 0; y < GRID_ROWS; y++) {
                    for (let x = 0; x < GRID_COLS; x++) {
                        if (!grid[y]) grid[y] = [];
                        if (!grid[y][x]) {
                            grid[y][x] = { type: 'empty', color: null };
                        } else if (typeof grid[y][x] === 'string') {
                            // Handle old format where grid cells were just strings
                            grid[y][x] = { type: grid[y][x], color: null };
                        }
                    }
                }

                rooms = new Map(data.rooms);
                hidingPlaces = new Map(data.hidingPlaces || []);

                // Initialize girlfriend with starting position
                gfImage = loadImage('assets/img/gf.png');
                girlfriend = new Girlfriend(gameState, girlfriendImg);
                girlfriend.setCharacterPosition(data.characterPos || { x: 0, y: 0 });

                // Initialize clown with starting position
                clown = new Clown(gameState, clownImg);
                // Start clown at a random room
                const roomEntries = Array.from(rooms.entries());
                const randomRoom = roomEntries[Math.floor(Math.random() * roomEntries.length)];
                if (randomRoom && randomRoom[1].length > 0) {
                    clown.setCharacterPosition(randomRoom[1][0]);
                }

                // Once loaded, initialize the P5 canvas with correct dims
                let canvas = createCanvas(GRID_COLS * CELL_SIZE, GRID_ROWS * CELL_SIZE);
                canvas.parent('mapWrapper');
                adjustScale();

            } catch (e) {
                console.error("Error loading apt.json:", e);
            }
        }

        function adjustScale() {
            const availableWidth = window.innerWidth - 400 - 40; // space for chat + margins
            const actualCanvasWidth = GRID_COLS * CELL_SIZE;
            const scale = availableWidth / actualCanvasWidth;
            const mapWrapper = document.querySelector('#mapSection .map-wrapper');
            if (mapWrapper) {
                mapWrapper.style.zoom = scale;
            }
        }

        window.addEventListener('resize', adjustScale);

        // p5.js setup
        function setup() {
            // We'll wait to createCanvas until apt.json is loaded
            window._p5 = window;

            baseMap = loadImage('/assets/img/appartment/BaseMap.PNG'); // Load the base map image
            girlfriendImg = loadImage('/assets/img/gf.png'); // Load the base map image
            clownImg = loadImage('/assets/img/clown.png'); // Load the base map image

            loadAptJson();
        }

        // p5.js draw loop
        function draw() {
            if (!grid || grid.length === 0) {
                // No grid loaded yet or apt.json not ready
                return;
            }
            // background(255);
            if (baseMap) {
                image(baseMap, 0, 0, GRID_COLS * CELL_SIZE, GRID_ROWS * CELL_SIZE);
            }
            // drawGrid();
            drawRooms();
            // drawWallsAndDoors();
            if (girlfriend) {
                girlfriend.drawPath(window._p5, CELL_SIZE);
                girlfriend.draw(window._p5, CELL_SIZE);
            }
            if (clown) {
                clown.checkForGirlfriend(girlfriend);
                clown.drawPath(window._p5, CELL_SIZE);
                clown.draw(window._p5, CELL_SIZE);
            }
        }

        function drawGrid() {
            stroke(200);
            for (let x = 0; x <= GRID_COLS; x++) {
                line(x * CELL_SIZE, 0, x * CELL_SIZE, GRID_ROWS * CELL_SIZE);
            }
            for (let y = 0; y <= GRID_ROWS; y++) {
                line(0, y * CELL_SIZE, GRID_COLS * CELL_SIZE, y * CELL_SIZE);
            }
        }

        function drawRooms() {
            for (let [roomName, cells] of rooms) {
                const hue = stringToHue(roomName);
                fill(hue, 30, 95, 0.3);
                noStroke();
                for (let cell of cells) {
                    rect(cell.x * CELL_SIZE, cell.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
                if (cells.length > 0) {
                    fill(0);
                    textAlign(CENTER, CENTER);
                    textSize(10);
                    text(
                        roomName,
                        cells[0].x * CELL_SIZE + CELL_SIZE / 2,
                        cells[0].y * CELL_SIZE + CELL_SIZE / 2
                    );
                }
            }

            for (let [hidingName, hideCells] of hidingPlaces) {
                // Draw the hiding place cells
                fill(100, 30, 95, 0.3);
                noStroke();
                for (let cell of hideCells) {
                    rect(cell.x * CELL_SIZE, cell.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }

                if (hideCells.length > 0) {
                    const x = hideCells[0].x * CELL_SIZE + CELL_SIZE / 2;
                    const y = hideCells[0].y * CELL_SIZE + CELL_SIZE / 2;

                    push();
                    textAlign(CENTER, CENTER);
                    textSize(10);

                    // Measure exactly the text size (no extra padding)
                    const labelWidth = textWidth(hidingName);
                    const labelHeight = textAscent() + textDescent();

                    // Draw a centered background rectangle 
                    // that's just as wide/tall as the text
                    rectMode(CENTER);
                    fill('#f1c94f');
                    noStroke();
                    rect(x, y, labelWidth, labelHeight / 2, 2);
                    pop();

                    // Draw the text on top
                    fill(0);
                    textAlign(CENTER, CENTER);
                    textSize(10);
                    text(hidingName, x, y);
                }
            }
        }

        function drawWallsAndDoors() {
            for (let y = 0; y < GRID_ROWS; y++) {
                for (let x = 0; x < GRID_COLS; x++) {
                    const cell = grid[y][x];
                    if (cell.type === 'wall') {
                        fill(0);
                        noStroke();
                        rect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    } else if (cell.type === 'door') {
                        fill(139, 69, 19); // Brown color for doors
                        noStroke();
                        rect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    } else if (cell.color) {
                        noStroke();
                        switch (cell.color) {
                            case 'yellow':
                                fill('#ffeb3b');
                                break;
                            case 'blue':
                                fill('#2196f3');
                                break;
                            case 'green':
                                fill('#4caf50');
                                break;
                            case 'red':
                                fill('#f44336');
                                break;
                        }
                        rect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
        }

        function stringToHue(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            return hash % 360;
        }

        // Simple BFS for pathfinding
        window.findPath = function (start, end) {
            const queue = [[start]];
            const visited = new Set();
            const key = pos => `${pos.x},${pos.y}`;
            visited.add(key(start));

            while (queue.length > 0) {
                const currentPath = queue.shift();
                const current = currentPath[currentPath.length - 1];

                if (current.x === end.x && current.y === end.y) {
                    return currentPath;
                }
                const neighbors = [
                    { x: current.x, y: current.y - 1 },
                    { x: current.x + 1, y: current.y },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x - 1, y: current.y }
                ];
                for (const next of neighbors) {
                    if (next.x < 0 || next.x >= GRID_COLS || next.y < 0 || next.y >= GRID_ROWS) continue;
                    if (visited.has(key(next))) continue;

                    const cell = grid[next.y][next.x];
                    if (cell.type === 'wall') continue;

                    visited.add(key(next));
                    queue.push([...currentPath, next]);
                }
            }
            return [];
        }

        function moveToRoom(roomName) {
            const targetRoom = Array.from(rooms.entries())
                .find(([name]) => name.toLowerCase() === roomName.toLowerCase());
            if (!targetRoom || !girlfriend) return false;

            const [_, cells] = targetRoom;
            if (cells.length === 0) return false;
            path = findPath(girlfriend.getCharacterPosition(), cells[0]);
            if (path.length > 0) {
                girlfriend.move(path);
                return true;
            }
            return false;
        }

        function moveToHidingSpot(hidingSpotName) {
            if (!girlfriend) return false;

            // Find the hiding place coordinates from apt.json data
            const hidingSpotData = Array.from(hidingPlaces.entries())
                .find(([name]) => name.toLowerCase() === hidingSpotName.toLowerCase());

            if (!hidingSpotData || !hidingSpotData[1] || hidingSpotData[1].length === 0) return false;

            // Use the first cell of the hiding place as the target
            const targetCell = hidingSpotData[1][0];
            path = findPath(girlfriend.getCharacterPosition(), targetCell);

            if (path.length > 0) {
                girlfriend.hide(path);
                return true;
            }
            return false;
        }

        /* Chat / Mistral-related code */
        function createLoadingIndicator() {
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'chat-message assistant-message';
            loadingDiv.innerHTML = `
                <div class="loading-dots">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                </div>
            `;
            return loadingDiv;
        }

        function addMessageToChat(role, content) {
            const chatHistory = document.getElementById('chatHistory');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}-message`;
            messageDiv.textContent = content;
            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;

            chatMessages.push({ role, content });

            if (role === "assistant" && localStorage.getItem("isSoundOn") !== "false") {
                playMessageSound();
            }
        }

        // Initialize Mistral API
        const mistralAPI = new MistralAPI();

        // Make rooms and hidingPlaces available globally
        window.rooms = rooms;
        window.hidingPlaces = hidingPlaces;

        // Update Message function to use girlfriend instance
        function Message() {
            if (girlfriend) {
                // Play message sound when sending a message
                if (localStorage.getItem("isSoundOn") !== "false") {
                    playMessageSound();
                }
                girlfriend.sendMessage();
            }
        }

        // Allow sending message with Enter
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('prompt').addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    Message();
                }
            });

            try {
                const bgMusic = document.getElementById("bgMusic");
                bgMusic.currentTime = 10;
                bgMusic.play().catch((error) => {
                    console.log("Autoplay prevented:", error);
                    isSoundOn = false;
                    updateSoundIcon();
                });
            } catch (error) {
                console.error("Error playing audio:", error);
            }
        });

        // Sound management code
        let isSoundOn = localStorage.getItem("isSoundOn") === null ? true : localStorage.getItem("isSoundOn") !== "false";
        const soundIcon = document.getElementById("soundIcon");
        const bgMusic = document.getElementById("bgMusic");

        // Make handleWalkingSound globally available
        window.handleWalkingSound = function (isWalking) {
            const walkingSound = document.getElementById("walkingSound");
            if (!walkingSound) return;

            if (isWalking && localStorage.getItem("isSoundOn") !== "false") {
                walkingSound.currentTime = 0;
                walkingSound.volume = 0.3;
                walkingSound.play().catch((error) => {
                    console.log("Could not play walking sound:", error);
                });
            } else {
                walkingSound.pause();
            }
        }

        // Update toggleSound to check girlfriend's movement status
        function toggleSound() {
            isSoundOn = !isSoundOn;
            localStorage.setItem("isSoundOn", isSoundOn.toString());

            if (isSoundOn) {
                if (bgMusic.currentTime < 10) {
                    bgMusic.currentTime = 10;
                }
                bgMusic.play();
                // Check if girlfriend exists and is moving
                if (girlfriend && girlfriend.isMoving) {
                    handleWalkingSound(true);
                }
            } else {
                bgMusic.pause();
                handleWalkingSound(false);
            }
            updateSoundIcon();
        }

        function updateSoundIcon() {
            soundIcon.src = isSoundOn ? "/static/assets/img/sondon.png" : "/static/assets/img/soundoff.png";
        }

        function playMessageSound() {
            try {
                const messageSound = document.getElementById("messageSound");
                if (messageSound) {
                    messageSound.currentTime = 0;
                    messageSound.volume = 1.0;
                    messageSound.play().catch((error) => {
                        console.log("Could not play message sound:", error);
                    });
                }
            } catch (error) {
                console.error("Error playing message sound:", error);
            }
        }
    </script>
</body>

</html>